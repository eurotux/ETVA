#!/usr/bin/perl
# Copywrite Eurotux 2009
# 
# CMAR 2009/04/03 (cmar@eurotux.com)

=pod

=head1 NAME

virtd - virtualization daemon

=head1 SYNOPSIS

    ./virtd

=head1 DESCRIPTION

    main

        load configuration

        start agent

            create new agent ETVA::Agent::SOAP using VirtAgentInterface as dispatcher

            $Agent->mainLoop()

                create Socket to Listen

                register on Central Management

                register alarm at T_ALARM seconds to send keep alive alert to Central Management

                accept connections from clients

=head1 METHODS

=over 4

=cut

use strict;

use ETVA::Utils;

use ETVA::Agent;
use ETVA::Agent::SOAP;
use ETVA::Agent::JSON;

use ETVA::GuestHandle;

use GuestAgent::Manager;

use VirtAgent;
use VirtAgent::Disk;
use VirtAgentSOAP;
use VirtAgentInterface;
use PollStats;

use ETVA::Client::SOAP::HTTP;

use POSIX;
use Data::Dumper;

my $AgentClass = 'VirtAgentSOAP';
my $Dispatcher = 'VirtAgentInterface';

# Config load from config file
my $CONF = { "CFG_FILE"=>"/etc/sysconfig/etva-vdaemon/virtd.conf" };

# tmp dir
my $TMP_DIR = "/var/tmp";

# guest management sockets dir
my $GUEST_MANAGEMENT_SOCKETS_DIR = "/var/tmp/virtagent-guestmngt-sockets-dir";

my $run_poll = 0;
my $RUNNING;
my @CHILD_PIDS;
my $GA_PID;
my $GM_PID;

# all stats data
my %StatsData = ();

=item launch_agent
start agent

    create ETVA::Agent::SOAP instance with VirtAgentInterface dispatcher module

=cut

sub launch_agent {
    # default active SOAP 
    #my $class = 'ETVA::Agent::SOAP';
    my $class = $AgentClass || 'VirtAgentSOAP';

    # TODO JSON requests not implemented 
    # can answer to JSON request
    #$class = $AgentClass = 'ETVA::Agent::JSON' if( $CONF->{'JSON'} );

    my $dispatcher = $Dispatcher || 'VirtAgentInterface';

    eval "require $dispatcher;";
    if( $@ ){
        die "virtd: Cant launch agent with this dispatcher: $dispatcher\n";
    }

    my %C = %$CONF;
    $C{'_dispatcher'} = $dispatcher;
    my %SI = VirtAgentInterface->getsysinfo();
    %C = (%SI,%C);

    $C{'LocalIP'} = $C{'LocalAddr'} if( !$C{'LocalIP'} );

    # register and keepalive func handlers
    $C{'_register_handler'} = \&register_handler;
    $C{'_alarmhandler_'} = $C{'_keepalive_handler'} = \&keepalive_handler;
    $C{'_termhandler_'} = \&term_handler;
    $C{'_chldhandler_'} = \&chld_handler;
    #$SIG{'CHLD'} = \&chld_handler;

    # initialization agent
	my $agent = $class->new( %C );
	
	if( $agent ){
        # start loop
		$agent->mainLoop();
	}
}

=item launch_virtio_guestagent
start guestagent

    create ETVA::Agent::SOAP instance with VirtAgentInterface dispatcher module

=cut

sub launch_virtio_guestagent {
    if( VirtAgentInterface->get_hypervisor_type() ne 'kvm' ){
        plog("launch_virtio guestagent hypervisor not support guest agent");
        return;
    }

    plog "Starting [host -> guest] agent \n" if( &debug_level > 3 );
    # create a child process to read the socket
    die "cant fork: $!" unless defined(my $kidpid = fork());

    # child scope ####
    if($kidpid==0){

        # rename process
        $0 .= " launch_virtio_guestagent";
    
        # Start working
        my $gm = GuestAgent::Manager->new('addr' => '127.0.0.1', 'port' => 7778, 'protocol' => 'tcp');
        plog("guest manager added");        

        $RUNNING = 1;
        while($RUNNING){
            eval {
                $gm->_readVa();
                $gm->_writeGuests();
            
                my @readga = $gm->_readGuests();
                $gm->_writeVa();

                &send_ga_info(\@readga);
            };
            if( $@ ){
                plogNow("launch_virtio_guestagent: something goes wrong with guest agent - $@");
            }
        }

        plog("launch_virtio_guestagent: go exit...");
        POSIX::_exit(0);
    } else {
        $GA_PID = $kidpid;
        ETVA::Utils::regpid($kidpid);
        plog "register child pid \n" if( &debug_level > 3 );
        push(@CHILD_PIDS,$kidpid);
    }    
}

sub launch_guestmanagement_handle {

    my $chldpid = fork();
    if( !defined($chldpid) ){
        die "cant fork: $!";
    }


    # guest management sockets dir
    $GUEST_MANAGEMENT_SOCKETS_DIR = $ENV{'gm_socket_dir'} || $CONF->{'gm_socket_dir'} || "$TMP_DIR/virtagent-guestmngt-sockets-dir";

    if( $chldpid==0 ){
        # child work

        # rename process
        $0 .= " launch_guestmanagement_handle";

        # configure handle of guest management agent sockets
        my $guestHandle = new ETVA::GuestHandle(
                                            LocalAddr   => $CONF->{'LocalIP'},
                                            LocalPort   => $CONF->{'LocalPort'}+2009,
                                            Proto       => 'tcp',
                                            'sockets_dir' => $GUEST_MANAGEMENT_SOCKETS_DIR,
                                            'cm_uri' => $CONF->{'cm_uri'},
                                            'cm_namespace' => $CONF->{'cm_namespace'},
                                            'typeuri' => $CONF->{'cm_namespace'}
                            );

        # put it loop
        $guestHandle->mainLoop();

        plogNow("launch_guestmanagement_handle: go exit...");

        POSIX::_exit(0);
    } else {
        $GM_PID = $chldpid;
        ETVA::Utils::regpid($chldpid);

        plogNow("launch_guestmanagement_handle register child pid") if( &debug_level > 3 );
        push(@CHILD_PIDS,$chldpid);
    }
}

sub send_ga_info {
    my ($ga_info) = @_;

    if( $CONF->{'cm_uri'} && $ga_info ){
        my @vms_ga_info = ();
        for my $g (@$ga_info){
            my $vmname = $g->{'guest'}{'vmname'};
            my $VM = VirtAgentInterface->getVM( 'name'=>$vmname );
            if( $VM ){
                my %G = ();
                $G{'uuid'} = $VM->get_uuid();
                $G{'msg'} = $g->{'msg'};
                $G{'timestamp'} = now();    # timestamp
                push(@vms_ga_info,\%G);
            }
        }
        if( @vms_ga_info ){
            plog( "updateVirtAgentGAInfo vms_ga_info:" . Dumper(\@vms_ga_info));
            my $R = new ETVA::Client::SOAP::HTTP( uri => $CONF->{'cm_uri'} )
                    -> call( $CONF->{'cm_namespace'},
                                'updateVirtAgentGAInfo',
                                uuid=>$CONF->{'uuid'},
                                data=>\@vms_ga_info
                            );
            plog( "updateVirtAgentGAInfo " . Dumper($R));
        }
    }
}

# load function
sub loadfunc {
    
    $CONF->{"CFG_FILE"} = $ENV->{'CFG_FILE'} if( $ENV{'CFG_FILE'} );
    $CONF = ETVA::Utils::get_conf(1,$CONF->{"CFG_FILE"});

    if( $CONF->{'DEBUG_FILE'} ){    # change debug file
        ETVA::Utils::closeDebugFile();
        ETVA::Utils::setDebugFile($CONF->{'DEBUG_FILE'});
    }

    &set_debug_level( $CONF->{'debug'} ); # set debug flag

    plog "CONF=",Dumper($CONF),"\n" if( &debug_level > 3 );
    VirtAgentInterface->loadsysinfo();
}

my %tStamps = ();

# polling domain stats
sub poll_stats {

    my $self = shift;
    my (%p) = @_;
    
    my %polldisks = PollStats->poll_disks();
    my %netstats = PollStats->poll_netstats();

    my %PathDisks = ();
    for my $D (values %polldisks){
        my $p = $D->{"path"};
        $PathDisks{"$p"} = $D;
    }

    my @stats = VirtAgent->domainStats();

    my %VMUpdated = ();

    for my $ds (@stats){
        my $id = $ds->{'id'};
        if( $id > 0 ){
            my $dn = $ds->{'name'};

            my $nts = $ds->{"timestamp"} || now();

            my $mmem = $ds->{'node_maxmem'};
            my $cmem = $ds->{'mem'};

            my $gctime = $ds->{'cputime'};
            my $ncpus = $ds->{'ncpus'};
            my $tcpus = $ds->{'node_maxcpus'};

            if( $tStamps{$dn} ){

                my $lts = $tStamps{$dn}{'lasttimestamp'} || 0;
                my $pmem = ($mmem<1024) ? 0 : ( $cmem * 100 / $mmem );   # percentage of memory
                my $s_pmem = sprintf('%0.2f',$pmem);

                my $lctime = $tStamps{$dn}{'lastcputime'};
                my $sctime = $gctime - $lctime;
                $sctime = 0 if( $sctime < 0 );  # prevent to be negative

                # total of cpu time
                my $totalcputime = (($nts - $lts) * 1000 * 1000 * 1000 * $tcpus );

                my $pcpu = 0;
                $pcpu = $sctime * 100 / $totalcputime if( $totalcputime > 0 );  # test for prevent illegal division

                my $s_pcpu = sprintf('%0.2f',$pcpu);

                plog "domain $dn cpu = $s_pcpu% ($sctime [$gctime] $ncpus) mem = $s_pmem% ($cmem $mmem)" if( &debug_level > 3 );

                $tStamps{$dn}{'cpu'}{'cpu_t'} = $sctime;
                $tStamps{$dn}{'cpu'}{'cpu_n'} = $ncpus;
                $tStamps{$dn}{'cpu'}{'cpu_per'} = $s_pcpu;
                $tStamps{$dn}{'cpu'}{'timestamp'} = $nts;
                $tStamps{$dn}{'memory'}{'mem_v'} = $cmem;
                $tStamps{$dn}{'memory'}{'mem_m'} = $mmem;
                $tStamps{$dn}{'memory'}{'mem_per'} = $s_pmem;
                $tStamps{$dn}{'memory'}{'timestamp'} = $nts;

                my $VM = VirtAgentInterface->updateStateVM( name=>$dn );
                if( $VM && !isError($VM) ){
                    # network interfaces
                    for(my $i=0; my $VI = $VM->get_network( i=>$i ); $i++){
                        if( my $vif = $VI->get_target() ){

                            for my $k ( keys %{$netstats{"$vif"}} ){
                                my $vk = $k;
                                # fix receive and transmit values
                                $vk =~ s/tx_/rx_/ or $vk =~ s/rx_/tx_/;

                                $tStamps{$dn}{'network'}{"$vif"}{"$vk"} = $netstats{"$vif"}{"$k"};
                            }

                            my %if_st = VirtAgentInterface->domInterfaceStats( name=>$dn, 'if'=>$vif );
                            if( !isError(%if_st) ){
                                # if could get stats from libvirt
                                for my $k ( keys %if_st ){
                                    $tStamps{$dn}{'network'}{"$vif"}{"$k"} = $if_st{"$k"};
                                }
                            }

                            $tStamps{$dn}{'network'}{"$vif"}{"i"} = $i;
                            $tStamps{$dn}{'network'}{"$vif"}{"macaddr"} = $VI->get_macaddr();
                        }
                    }
                    # disk devices
                    for(my $i=0; my $VD = $VM->get_disk( i=>$i ); $i++){
                        if( $VD->get_device() eq 'disk' ){  # ignore none disks
                            if( my $path = $VD->get_path() ){
                                my $target = $VD->get_target();

                                $tStamps{$dn}{'disk'}{"$target"} = $PathDisks{"$path"} if( $PathDisks{"$path"}  );

                                my %d_st = VirtAgentInterface->domBlockStats( name=>$dn, dev=>$target );
                                if( !isError(%d_st) ){
                                    # if could get stats from libvirt
                                    for my $k (keys %d_st){
                                        $tStamps{$dn}{'disk'}{"$target"}{"$k"} = $d_st{"$k"};
                                    }
                                }
                                $tStamps{$dn}{'disk'}{"$target"}{"path"} = $path;
                            }
                        }
                    }
                }
            }

            $VMUpdated{"$dn"} = $tStamps{$dn}{'lasttimestamp'} = $tStamps{$dn}{'timestamp'} = $nts;  # update time stamp
            $tStamps{$dn}{'lastcputime'} = $gctime; # cpu time
        }

    }
    
    for my $vm (keys %tStamps){
        if( !$VMUpdated{"$vm"} ){
            # VM doenst exist any more
            #  delete from statistics
            delete $tStamps{"$vm"};
        }
    } 

    return wantarray() ? %tStamps: \%tStamps;
}

# send stats
sub send_stats {
    
    my $now = now();        # now unix time stamp
    my $now_s = nowStr();   # now string

    my %stats = ( );
    $stats{"time_s"} = $now_s;
    $stats{"time"} = $stats{"timestamp"} = $now_s;

    # load stats
    my %load_stats = $stats{"load"} = PollStats::poll_loadstats();

    # cpu stats
    my %cpu_stats = $stats{"cpu"} = PollStats::poll_cpustats();

    # memory stats
    my %mem_stats = $stats{"memory"} = PollStats::poll_memstats(); 

    # network interfaces stats
    # CMAR 10/01/2011   dont send
    #my %net_stats = $stats{"network"} = PollStats::poll_netstats();
    PollStats::poll_netstats();

    # disks stats
    # CMAR 10/01/2011   dont send
    #my %disk_stats = $stats{"disk"} = PollStats::poll_disks();
    PollStats::poll_disks();

    # stats for virtual machines
    my %st = my %st_vm = poll_stats();
    for my $vm (keys %st_vm){
        # ignore if no cpu and no memory statistics
        if( !$st_vm{"$vm"}{"cpu"} &&
            !$st_vm{"$vm"}{"memory"} ){
            delete $st_vm{"$vm"};
        }
    }
    $stats{"virtualmachines"} = \%st_vm;

    plog Dumper(\%stats),"\n" if( &debug_level > 3 );

    return wantarray() ? %stats : \%stats;
}

=item main

simple startup

=over

=item *

load configuration stuff

=item *

launch agent

=back

=cut

# simple startup
sub main {

    my $debugfile_path = $ENV{'DEBUG_FILE'} || "/var/log/etva-vdaemon/virtdDebug.log";
    ETVA::Utils::setDebugFile($debugfile_path);

    ETVA::Utils::killpids();    # kill previous pids

    ETVA::Utils::regpid();

    $SIG{'HUP'} = $SIG{'TERM'} = \&term_handler;

    # load stuff
    loadfunc();

    # tmp dir
    $TMP_DIR = $CONF->{'tmpdir'} if( $CONF->{'tmpdir'} );

    # init stats
    poll_stats();

    # call guest agent process  
    &launch_virtio_guestagent();

    # launch handle guest management agents
    &launch_guestmanagement_handle();

    # call soap process
    launch_agent();

    ETVA::Utils::killpids();    # kill previous pids
}

sub term_handler {
    $RUNNING = 0;

    plogNow("[ERROR] - virtd - receive term signal... deamon terminate!");

    plogNow("[ERROR] - virtd - ...waiting for childs...\n");

    if( defined($GM_PID) ){
        kill SIGKILL, $GM_PID;
        sleep(2);
        waitpid(-1,&WNOHANG);
    }

    for my $cpid (@CHILD_PIDS){
        kill SIGHUP, $cpid;
        sleep(2);
        waitpid(-1,&WNOHANG);
    }
}

sub chld_handler {
    plogNow "[info] - virtd - receiving chld signal..." if( &debug_level > 5 );

    #ETVA::Utils::timeout_call(30, sub { 
        # don't change $! and $? outside handler
        local ($!, $?);

        # wait for die pid
        my $dead_pid = waitpid(-1,&WNOHANG);

        while($dead_pid > 0){

            #last unless WIFEXITED($?);
            #last unless &chld_exists($dead_pid);

            plogNow(" sigchld_handler wait dead pid=$dead_pid") if( &debug_level() > 5);
            &chld_dies_handler($dead_pid);

            $dead_pid = waitpid(-1,&WNOHANG);
        }
    #});

    # don't change $! and $? outside handler
    #local ($!, $?);

    # wait for die pid
    #my $dead_pid = waitpid(-1,&WNOHANG);

    #return if( $dead_pid == -1 );
    #return unless WIFEXITED($?);
    #return unless &chld_exists($dead_pid);

    #plogNow(" sigchld_handler wait dead pid=$dead_pid") if( &debug_level() > 5);

    #&chld_dies_handler($dead_pid);
}

sub chld_exists {
    my ($dead_pid) = @_;

    # for guest agent process
    if( defined($GA_PID) && ($dead_pid == $GA_PID) ){
        return 1;
    }

    # for guest management handle process
    if( defined($GM_PID) && ($dead_pid == $GM_PID) ){
        return 1;
    }

    # other child process
    my $cc = $AgentClass->can('chld_exists');
    if( $cc ){
        return &$cc($dead_pid);
    }

    return 0;
}
sub chld_dies_handler {
    my ($dead_pid) = @_;

    if( defined($GA_PID) || defined($GM_PID) ){
        &chld_handler_GA($dead_pid);
    }

    my $ch = $AgentClass->can('chld_dies_handler');
    if( $ch ){
        &$ch($dead_pid);
    }
}

sub chld_handler_GA {
    my ($kpid) = @_;

    # for guest agent process
    if( (defined($GA_PID) && ($kpid == $GA_PID)) ||
            (defined($GM_PID) && ($kpid == $GM_PID)) ){

        $RUNNING = 0;

        # for guest agent process
        if( defined($GA_PID) && ($kpid == $GA_PID) ){
            plogNow("[ERROR] - virtd - guest agent die... deamon go terminate! (kpid=$kpid GA_PID=$GA_PID)");

            #VirtAgentSOAP->terminate_agent();   # terminate agent
            #kill SIGHUP, $$; # kill my self

            plogNow("[ERROR] - guest agent die... so i will die too...");
        }

        # for guest management handle process
        if( defined($GM_PID) && ($kpid == $GM_PID) ){
            plogNow "[ERROR] - virtd - guest management handle process die... deamon go terminate! (kpid=$kpid GM_PID=$GM_PID)";

            #VirtAgentSOAP->terminate_agent();   # terminate agent
            #kill SIGHUP, $$; # kill my self

            plogNow("[ERROR] - guest management handle process die... so i will die too...");
        }
        #die "guest process die... so i will die too...";
    }
}

my $REGISTER_OK = 0;

sub register_handler {
    my ($agent) = @_;

    # TODO change this for Generic Agent
    my $laddr = $agent->{'LocalAddr'} || "*";
    my $port = $agent->{'LocalPort'};
    my $proto = $agent->{'Proto'};

    plogNow("agent initialized listen in addr=$laddr ip=$agent->{'LocalIP'} memtotal=>$agent->{'maxmem'} memfree=>$agent->{'meminfo'}{'MemFree'} cputotal=>$agent->{'maxncpu'} port=$port proto=$proto uuid=$agent->{'uuid'}");
    plog("CM info cm_uri=> $agent->{'cm_uri'}, cm_namespace=$agent->{'cm_namespace'}\n");

#    return;
    # initialized on CentralManagement
    # using HTTP request
    # TODO change this to make possible others protocols
    # CM testing...
    if( $agent->{'cm_uri'} ){

        my $R = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'}, debug=>&debug_level )
                -> call( $agent->{'cm_namespace'},
                            'initializeVirtAgent',
                            'args'=>{
                                name=>$agent->{'name'},
                                memtotal=>$agent->{'maxmem'},
                                memfree=>$agent->{'meminfo'}{'MemFree'},
                                storagedir=>$agent->{'storagedir'},         # send storage dir configuration
                                cputotal=>$agent->{'maxncpu'},
                                netcards=>$agent->{'netcount'},
                                ip=>$agent->{'LocalIP'},
                                port=>$agent->{'LocalPort'},
                                uuid=>$agent->{'uuid'},
                                hypervisor=>$agent->{'hypervisor_type'},
                                state=>1,
                            }
                        );

        if( !$R || $R->{'_error_'} || (ref($R->{'return'}) && !$R->{'return'}{'success'} && $R->{'return'}{'error'}) ){
            plogNow("Cant connect to CentralManagement.\nInitialization Agent aborted!");
            if( &debug_level && !$R->{'return'}{'success'} && $R->{'return'}{'error'} ){
                plog("\tReason: ",Dumper($R->{'return'}{'error'}));
            }

            plog(" Agent going down!");
            $agent->set_runout();
        } else {
            if( ref($R->{'return'}) && $R->{'return'}{'success'} && $R->{'return'}{'success'} ne 'false' ){

                if( $R->{'return'}{'state'} < VirtAgentInterface::NODE_INACTIVE ){
                    plog(" Agent state is not active state=".$R->{'return'}{'state'} );
                }

                $agent->{'_cm_insert_id'} = $R->{'return'}{'insert_id'};

                my $now = nowStr();

                # update uuid from Central Management
                if( $R->{'return'}{'uuid'} && 
                    ( $R->{'return'}{'uuid'} ne $agent->{'uuid'} ) ){
                    plog("$now - Agent uuid changed! Old uuid=",$agent->{'uuid'}," new uuid=",$R->{'return'}{'uuid'});
                    $CONF->{'uuid'} = $agent->{'uuid'} = $R->{'return'}{'uuid'};
                    VirtAgentInterface->setuuid($agent->{'uuid'});
                }
                if( $R->{'return'}{'keepalive_update'} ){
                    my $keepalive_t = $R->{'return'}{'keepalive_update'};
                    plog("$now - keepalive time update - $keepalive_t");
                    $agent->set_t_alarm( 'T_ALARM'=>$keepalive_t );
                    $CONF->{'T_ALARM'} = $keepalive_t;
                }

                if( $R->{'return'}{'name'} &&
                    ( $R->{'return'}{'name'} ne $agent->{'name'} ) ){
                    plog("$now - Agent name changed! Old name=",$agent->{'name'}," new name=",$R->{'return'}{'name'});
                    $CONF->{'name'} = $agent->{'name'} = $R->{'return'}{'name'};
                    $agent->change_va_name($agent->{'name'});
                }

                # check and generate CA and Server certificates
                if( !ETVA::Utils::checkcertificates( $CONF->{'Organization'}, $agent->{'name'} ) ){
                    if( ETVA::Utils::checkCAExpires() ){
                        # TODO Need to update!!!
                        plogNow("CA Certificate expires and need to be updated!");
                    }
                }

                # configure ntp
                $agent->update_ntp_config();

                plog("$now - Agent initialized with success on CentralManagement: id=$agent->{'_cm_insert_id'}");

                my $resetError;         # reset Error
                if( $R->{'return'}{'reset'} ){
                    plog(" reset = ",Dumper($R->{'return'}));

                    VirtAgentInterface->set_backupconf( '_url'=>"$R->{'return'}{'backup_url'}" );
                    # load old conf
                    my %old_CONF = ETVA::Utils::get_conf(1,$CONF->{"CFG_FILE"});
                    # merge with new conf
                    $CONF = {%old_CONF, %$CONF};
                    # save to file
                    ETVA::Utils::set_conf($CONF->{"CFG_FILE"},%$CONF);

                    # reset previous state
                    my $vms = VirtAgentInterface->list_vms();
                    for my $hVM (@$vms){
                        plog("VirtAgentInterface->destroy_vm( 'uuid'=>$hVM->{'uuid'}, 'keep_fs'=>0 );") if( &debug_level > 5 );
                        VirtAgentInterface->destroy_vm( 'uuid'=>$hVM->{'uuid'}, 'keep_fs'=>0 );
                    }
                    my $lvs = VirtAgentInterface->getlvs();
                    for my $hLV (values %$lvs){
                        if( !$hLV->{'deviceopen'} ){
                            plog("VirtAgentInterface->lvremove( 'uuid'=>$hLV->{'uuid'}, 'vg'=>$hLV->{'vg'}, 'lv'=>$hLV->{'path'} );") if( &debug_level > 5 );
                            VirtAgentInterface->lvremove( 'uuid'=>$hLV->{'uuid'}, 'vg'=>$hLV->{'vg'}, 'lv'=>$hLV->{'path'} );
                        }
                    }
                    $lvs = VirtAgentInterface->getlvs();

                    my $vgs = VirtAgentInterface->getvgs();
                    for my $hVG (values %$vgs){
                        next if( $hVG->{'vg'} eq '__DISK__' );
                        if( !grep { $hVG->{'vg'} eq $_->{'vg'} } values %$lvs ){ # if dont have lv on volume group
                            plog("VirtAgentInterface->vgremove( 'uuid'=>$hVG->{'uuid'}, 'name'=>$hVG->{'vg'} );") if( &debug_level > 5 );
                            VirtAgentInterface->vgremove( 'uuid'=>$hVG->{'uuid'}, 'name'=>$hVG->{'vg'} );
                        }
                    }
                    $vgs = VirtAgentInterface->getvgs();

                    my $pvs = VirtAgentInterface->getpvs();
                    for my $hPV (values %$pvs){
                        if( !$hPV->{'vg'} ){                # if not in VG
                            plog("VirtAgentInterface->pvremove( 'uuid'=>$hPV->{'uuid'}, 'device'=>$hPV->{'device'} );") if( &debug_level > 5 );
                            VirtAgentInterface->pvremove( 'uuid'=>$hPV->{'uuid'}, 'device'=>$hPV->{'device'} );
                        }
                    }
                    $pvs = VirtAgentInterface->getpvs();

                    if( !$resetError && $R->{'return'}{'pvs'} ){
                        my $ipvs = $R->{'return'}{'pvs'};
                        for my $hPVi (@$ipvs){
                            if( !grep { $hPVi->{'device'} eq $_->{'device'} } values %$pvs ){
                                plog("VirtAgentInterface->pvcreate( %$hPVi );") if( &debug_level > 5 );
                                my $e = VirtAgentInterface->pvcreate( $hPVi->{'device'} );
                                if( isError($e) ){
                                    $resetError = $e;
                                    last;
                                }
                            }
                        } 
                    }
                    if( !$resetError && $R->{'return'}{'vgs'} ){
                        my $ivgs = $R->{'return'}{'vgs'};
                        for my $hVGi (@$ivgs){
                            next if( $hVGi->{'vg'} eq '__DISK__' );     # ignore special VG
                            if( !grep { $hVGi->{'vg_name'} eq $_->{'vg'} } values %$vgs ){
                                plog("VirtAgentInterface->vgcreate( $hVGi->{'vg_name'}, $hVGi->{'physicalvolumes'} );") if( &debug_level > 5 );
                                my $e = VirtAgentInterface->vgcreate( $hVGi->{'vg_name'}, $hVGi->{'physicalvolumes'} );
                                if( isError($e) ){
                                    $resetError = $e;
                                    last;
                                }
                            }
                        } 
                    }
                    if( !$resetError && $R->{'return'}{'lvs'} ){
                        my $ilvs = $R->{'return'}{'lvs'};
                        for my $hLVi (@$ilvs){
                            if( !grep { $hLVi->{'lv_name'} eq $_->{'lv'} } values %$lvs ){
                                my $lv_size = str2size($hLVi->{'size'});
                                plog("VirtAgentInterface->lvcreate( $hLVi->{'lv_name'}, $hLVi->{'volumegroup'}, \"${lv_size}B\" );") if( &debug_level > 5 );
                                my $e = VirtAgentInterface->lvcreate( $hLVi->{'lv_name'}, $hLVi->{'volumegroup'}, "${lv_size}B" );
                                if( isError($e) ){
                                    $resetError = $e;
                                    last;
                                }
                            }
                        } 
                    }

                    if( $resetError ){
                        # send to CM
                        my $R = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'}, debug=>&debug_level )
                                -> call( $agent->{'cm_namespace'},
                                            'clearVirtAgent',
                                            uuid=>$agent->{'uuid'},
                                            error=>{ 'error'=>$resetError->{'_error_'}, 'errordetail'=>$resetError->{'_errordetail_'}, 'errorstring'=>$resetError->{'_errorstring_'}, 'errorcode'=>$resetError->{'_errorcode_'} }
                                            );
                    }
                }

                # try send list of networks
                my $networks = VirtAgentInterface->list_networks(1);
                plog "networks=",Dumper($networks) if( &debug_level > 3 );
                my $networks_arr = [];
                if( $networks ){
                    my @l = values %$networks;
                    $networks_arr = \@l;
                }

                my $RN = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'} )
                        -> call( $agent->{'cm_namespace'},
                                    'updateVirtAgentVlans',
                                    uuid=>$agent->{'uuid'},
                                    vlans => [] # send empty array to receive all networks $networks_arr
                                );
                plog "RN=",Dumper($RN) if( &debug_level > 3 );
                # waiting for networks to create
                if( $RN && $RN->{'return'} ){
                    my $r_networks = $RN->{'return'};
                    if( ref($r_networks) ){ # testing if is a reference else ignore...
                        plog "lnets=",Dumper($r_networks) if( &debug_level > 3 );

                        # destroy networks not send from CM
                        for my $N (@$networks_arr){
                            my $n_name = $N->{'name'};
                            my $n_uuid = $N->{'uuid'};
                            
                            if( !$r_networks->{"$n_name"} ){
                                VirtAgentInterface->destroy_network( 'name'=> $n_name, 'uuid'=>$n_uuid )
                            }
                        }
                        # create them
                        for my $N (values %$r_networks){
                            if( ref($N) ){                      # testing if is a reference else ignore...
                                my $n_name = $N->{'name'};
                                if( !$networks->{"$n_name"} ){
                                    VirtAgentInterface->create_network( %$N );
                                }
                            }
                        }
                    }
                }

                # try send list for disk devices
                my $devs = VirtAgentInterface->hash_phydisks();
                plog "devs=",Dumper($devs) if( &debug_level > 3 );

                my $RD = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'} )
                        -> call( $agent->{'cm_namespace'},
                                    'updateVirtAgentDevices',
                                    uuid=>$agent->{'uuid'},
                                    devs => $devs
                                );
=pod

=begin comment    # not in use

                # try send list for physical volumes
                my $pvs = VirtAgentInterface->getpvs();
                plog "pvs=",Dumper($pvs) if( &ebug_level  > 3 );

                my $RP = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'} )
                        -> call( $agent->{'cm_namespace'},
                                    'updateVirtAgentPvs',
                                    uuid=>$agent->{'uuid'},
                                    pvs => $pvs
                                );
                plog "PHYSICAL VOLUMES=",Dumper($RP) if( &debug_level > 3 );

=end comment

=cut

                # try send list for volumes groups
                my $vgs = VirtAgentInterface->getvgpvs();
                plog "vgs=",Dumper($vgs) if( &debug_level > 3 );

                my $RG = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'} )
                        -> call( $agent->{'cm_namespace'},
                                    'updateVirtAgentVgs',
                                    uuid=>$agent->{'uuid'},
                                    vgs => $vgs
                                );
                plog "VOLUME GROUPS=",Dumper($RG) if( &debug_level > 3 );

                # try send list for logical volumes
                my $lvs = VirtAgentInterface->getlvs();
                plog "lvs=",Dumper($lvs) if( &debug_level > 3 );
                my @a_lvs = values %$lvs;   # convert to array

                my @dtable = VirtAgentInterface->device_table();

                my $RL = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'} )
                        -> call( $agent->{'cm_namespace'},
                                    'updateVirtAgentLvs',
                                    uuid=>$agent->{'uuid'},
                                    lvs => \@a_lvs,
                                    'devicetable' => \@dtable
                                );
                plog "LOGICAL VOLUMES=",Dumper($RL) if( &debug_level > 3 );

                # try send list for VMs
                my $vms = VirtAgentInterface->hash_vms();

                plog "vms=",Dumper($vms) if( &debug_level > 3 );

                my $RV = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'}, debug=>&debug_level )
                        -> call( $agent->{'cm_namespace'},
                                    'syncVirtAgentServers',
                                    uuid=>$agent->{'uuid'},
                                    vms => $vms
                                );
                plog "RV=",Dumper($RV) if( &debug_level > 3 );
                # waiting for virtual machines to create
                if( $RV && $RV->{'return'} ){
                    if( $RV->{'return'}{'success'} ){

                        my $vms_to_destroy = $RV->{'return'}{'destroy_servers'};
                        plog "vms to destroy=",Dumper($vms_to_destroy) if( &debug_level > 3 );
                        if( ref($vms_to_destroy) eq 'ARRAY' ){
                            # destroy them
                            for my $vm (@$vms_to_destroy){
                                if( ref($vm) ){                 # testing if is a reference else ignore...
                                    VirtAgentInterface->destroy_vm( 'uuid'=>$vm->{'uuid'} );
                                }
                            }
                        }

                        my $vmachines = $RV->{'return'}{'load_servers'};
                        plog "lvms=",Dumper($vmachines) if( &debug_level > 3 );
                        # create them
                        if( ref($vmachines) eq 'ARRAY' ){
                            for my $vm (@$vmachines){
                                if( ref($vm) ){                 # testing if is a reference else ignore...
                                    my $state = $vm->{"vm_state"};
                                    my $name = $vm->{"name"};
                                    my $E;
                                    if( !$vms->{"$name"} ){
                                        plog "creating name=$name","\n";
                                        $E = VirtAgentInterface->create_vm( %$vm ); 
                                    }

                                    if( !$E || isError($E) ){
                                        # trying to reload vm info
                                        plog "try to reload name=$name","\n";
                                        $E = VirtAgentInterface->reload_vm( %$vm );
                                        if( isError($E) ){
                                            # TODO think more about it
                                            # ignore this one
                                            plog "Something goes wrong with server '$name'. I will ignore it.";
                                            next;
                                        }
                                    }

                                    # previous state is runnig: start it
                                    if( ($state eq "running") || $vm->{'autostart'} ){
                                        plog "starting name=",$vm->{"name"}," boot=",$vm->{'boot'},"\n";
                                        VirtAgentInterface->start_vm( name=>$vm->{"name"}, boot=>$vm->{'boot'} );
                                    } 
                                } 
                            }
                        }
                    }
                } else {
                    plogNow("[ERROR] Error at synchronize virtual servers... ",Dumper($RV));
                }

                if( !$resetError && $R->{'return'}{'reset'} ){
                    my $reset_ok = retOk("_OK_","ok");
                    my $RR = new ETVA::Client::SOAP::HTTP( uri => $agent->{'cm_uri'} )
                            -> call( $agent->{'cm_namespace'},
                                        'restoreVirtAgent',
                                        uuid=>$agent->{'uuid'},
                                        ok=>{ 'oktype'=>$reset_ok->{'_oktype_'}, 'okmsg'=>$reset_ok->{'_okmsg_'} }
                                    );
                }
                
                $agent->set_registerok( ($R->{'return'}{'uuid'})? ($REGISTER_OK = 1) : ($REGISTER_OK = 0));
            } else {

                $agent->set_registerok( $REGISTER_OK = 0 );

                my $response = "";
                if( ref($R->{'return'}) && $R->{'return'}{'response'} ){
                    $response = $R->{'return'}{'response'};
                }

                plog( "Error initialize Agent: $response.\n" );
            }

            # Get ssh key
            open my $authkeys, "</root/.ssh/authorized_keys";
            #open my $authkeys, "</tmp/authorized_keys";
            my $key = 0;
            while(<$authkeys>){
                my $tmpkey = "";
                if($R->{'return'}{'cmpubkey'} =~ /([^=]*)/){
                    $tmpkey = $1;
                }
                if($_ =~ /\Q$tmpkey\E/){
                    $key = 1;    
                }
            }
            close $authkeys;
            unless($key){
                open $authkeys, ">>/root/.ssh/authorized_keys";
                #open $authkeys, ">>/tmp/authorized_keys";
                print $authkeys $R->{'return'}{'cmpubkey'};
                close $authkeys;
            }
        }
    }
}

sub keepalive_handler {

    plogNow("Keepalive... REGISTER_OK=$REGISTER_OK ... \n");

    if( $REGISTER_OK ){

        # TODO change this for Generic Agent
        # CM testing...
        if( $CONF->{'cm_uri'} ){
            plogNow("updateVirtAgent ip state and mdstat");
            my $checkmdstat = 1;
            my $R = VirtAgent::Disk->check_mdstat();
            if( isError($R) ){
                $checkmdstat = 0;
            }
            plogNow("updateVirtAgent ip state and mdstat = $checkmdstat R=",Dumper($R));
            # update state
            my $R = new ETVA::Client::SOAP::HTTP( uri => $CONF->{'cm_uri'} )
                    -> call( $CONF->{'cm_namespace'},
                                'updateVirtAgent',
                                uuid=>$CONF->{'uuid'},
                                #field=>'state',value=>1,
                                'data'=>{
                                    ip=>$CONF->{'LocalIP'},
                                    state=>1,
                                },
                                'checkmdstat'=>{ 'success'=>$checkmdstat, 'message'=>$R->{'_okmsg_'}||$R->{'_errdetail_'}, %$R }
                            );
            if( !$R || $R->{'_error_'} ){
                plogNow("Error CentralManagement connection problem.\n");
            } else {
                if( ref($R->{'return'}) && $R->{'return'}{'success'} && $R->{'return'}{'success'} ne 'false' ){
                    plogNow("Agent keepalive state update successful.");
                } else {
                    plogNow( "Error update Agent.\n" );
                    if( &debug_level ){
                        if( ref($R->{'return'}) && !$R->{'return'}{'success'} && $R->{'return'}{'error'} ){
                            plog("\tReason: ",Dumper($R->{'return'}{'error'}));
                        } else {
                            plog("\tDebug: ",Dumper($R));
                        }
                    }
                }
            }
        }

        my $bef_cur_mem = ETVA::Utils::process_mem_size($$);
        my $stats;
        my $timeout_blockstats = 10;    # time out for blockstats (default: 10s)
        my $bkp_alrmhandler = $SIG{ALRM} || sub {};   # backup it
        eval {
            local $SIG{ALRM} = sub { die "Domain block_stats: Timeout!\n"; };
            alarm($timeout_blockstats);
            $stats = send_stats();
            alarm(0);
        };
        my $err = $@;	# backup error message
        $SIG{ALRM} = $bkp_alrmhandler;   # restore it
        if( $err ){
            plogNow("[ERROR] - keepalive_handler - send_stats error: $@");
        }
        my $aft_cur_mem = ETVA::Utils::process_mem_size($$);

        my $diff_cur_mem = $aft_cur_mem - $bef_cur_mem;
        my $diff_cur_mem_ps = ETVA::Utils::prettysize($diff_cur_mem);
        my $aft_cur_mem_ps = ETVA::Utils::prettysize($aft_cur_mem);

        plogNow(sprintf('%s: MEMORY_LEAK virtd method=send_stats memory detect cur_mem=%s (diff=%s)',ETVA::Utils::nowStr(0),$aft_cur_mem_ps,$diff_cur_mem_ps)) if(&debug_level > 9);

        if( $stats ){
            if( $CONF->{'cm_uri'} ){
                # update state
                my $R = new ETVA::Client::SOAP::HTTP( uri => $CONF->{'cm_uri'} )
                    -> call( $CONF->{'cm_namespace'},
                                    'updateVirtAgentLogs',
                                    uuid=>$CONF->{'uuid'},
                                    data=>$stats
                                );
                if( !$R || $R->{'_error_'} ){
                    plogNow("Error CentralManagement connection problem.\n");
                } else {
                    if( ref($R->{'return'}) && $R->{'return'}{'success'} && $R->{'return'}{'success'} ne 'false' ){
                        plogNow("Agent keepalive logs send successful.");
                    } else {
                        plogNow( "Error update Agent Logs.\n" );
                        if( &debug_level ){
                            if( ref($R->{'return'}) && !$R->{'return'}{'success'} && $R->{'return'}{'error'} ){
                                plog("\tReason: ",Dumper($R->{'return'}{'error'}));
                            } else {
                                plog("\tDebug: ",Dumper($R));
                            }
                        }
                    }
                }
            }
        }
    }
}
main();
1;

=back

=pod

=head1 BUGS

...

=head1 AUTHORS

...

=head1 COPYRIGHT

...

=head1 LICENSE

...

=head1 SEE ALSO

L<VirtAgentInterface>, L<VirtAgent::Disk>, L<VirtAgent::Network>,
L<VirtMachine>
C<http://libvirt.org>
L<ETVA::Agent>, L<ETVA::Agent::SOAP>, L<ETVA::Agent::JSON>
L<ETVA::Client>, L<ETVA::Client::SOAP>, L<ETVA::Client::SOAP::HTTP>

=cut
